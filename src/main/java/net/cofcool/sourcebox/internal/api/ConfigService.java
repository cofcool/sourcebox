package net.cofcool.sourcebox.internal.api;

import io.vertx.core.Future;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import lombok.CustomLog;
import net.cofcool.sourcebox.internal.api.entity.Config;
import net.cofcool.sourcebox.util.JsonUtil;
import net.cofcool.sourcebox.util.SqlRepository;
import net.cofcool.sourcebox.util.VertxUtils.JDBCPoolConfig;

@CustomLog
public class ConfigService {

    static final int DB_VERSION = 4;

    private static final class ServiceHolder {
        private static final ConfigService SERVICE = new ConfigService();
    }

    public static ConfigService getService() {
        return ServiceHolder.SERVICE;
    }

    private final SqlRepository<Config> repository = SqlRepository.create(Config.class);

    public Future<Config> put(String key, String val) {
        return repository.save(new Config(key, val, LocalDateTime.now()));
    }

    public Future<Config> put(String key, Object val) {
        return repository.save(new Config(key, JsonUtil.toJson(val), LocalDateTime.now()));
    }

    public <T> Future<T> get(String key, Class<T> clazz) {
        return repository.find(key).compose(c -> Future.succeededFuture(JsonUtil.toPojo(c.data(), clazz)));
    }

    public Future<String> get(String key) {
        return repository.find(key).compose(c -> Future.succeededFuture(c.data()));
    }

    public Future<String> get(String key, String defaultVal) {
        return repository.find(key)
            .compose(c -> Future.succeededFuture(c.data()))
            .otherwise(e -> {
                log.info("Get config {0} error: {1}", key, e.getMessage());
                return defaultVal;
            });
    }

    public Future<Config> getConfig(String key) {
        return repository.find(key).compose(Future::succeededFuture);
    }

    public static void migrator(JDBCPoolConfig config) throws Exception {
        Map<Integer, List<String>> migrationSteps = new LinkedHashMap<>();

        migrationSteps.put(2, List.of(
            "ALTER TABLE action_record ADD COLUMN remark VARCHAR(512) null",
            "ALTER TABLE action_record ALTER COLUMN device SET NULL"
        ));

        migrationSteps.put(3, List.of(
            "ALTER TABLE action_record ALTER COLUMN device SET NULL"
        ));

        migrationSteps.put(4, List.of(
            "ALTER TABLE action_record ALTER COLUMN name VARCHAR(512)"
        ));

        try (Connection conn = DriverManager.getConnection(config.getUrl());
            Statement stmt = conn.createStatement()
        ) {
            stmt.executeUpdate("""
                    CREATE TABLE IF NOT EXISTS db_version (
                        id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        version INTEGER NOT NULL,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );
                """);

            int currentVersion = 0;
            try (ResultSet rs = stmt.executeQuery(
                "SELECT version FROM db_version ORDER BY updated_at DESC LIMIT 1")) {
                if (rs.next()) {
                    currentVersion = rs.getInt("version");
                }
            }

            if (currentVersion == 0) {
                currentVersion = DB_VERSION;
            }

            boolean flag = false;
            for (Map.Entry<Integer, List<String>> entry : migrationSteps.entrySet()) {
                Integer targetVersion = entry.getKey();
                if (targetVersion > currentVersion) {
                    for (String sql : entry.getValue()) {
                        stmt.executeUpdate(sql);
                        log.info("execute migrate sql: " + sql);
                    }
                    flag = true;
                    updateDBVersion(stmt, targetVersion);
                    currentVersion = targetVersion;
                }
            }

            if (DB_VERSION != currentVersion) {
                flag = true;
                updateDBVersion(stmt, DB_VERSION);
            }

            if (flag) {
                log.info("migrate ok, current version is " + currentVersion);
            }
        }
    }

    private static void updateDBVersion(Statement stmt, Integer targetVersion) throws SQLException {
        int code = stmt.executeUpdate(
            "INSERT INTO db_version (version) VALUES ('" + targetVersion + "')");
        if (code == 0) {
            throw new IllegalStateException("update db_version error");
        }
    }

}
